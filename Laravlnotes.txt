Laravel : 
##Routes:

1. Normal routes:
Route::get('/',function(){
	return view('welcome');
})
Route::get('/',ControllerName@Methodname);
Route::post('/',ControllerName@Methodname);

2. Route with Required Parameters : 
Route::get('hello/{name}',function($name){
	echo $name;
});
Route::get('hello/{name}', ControllerName@Methodname);

3. Route with Optional parameters:
Route::get('hello/{name?}',function($name=''){
	echo $name;
});
Route::get('hello/{name}/{address?}', ControllerName@Methodname);

3. Route with Optional parameter having regex pattern
Route::get('hello/{number}','c@m')->where(['number'=>"[0-9]+"]);

4. Named Routes by using name or as
i. Route::get('user/profile','UserController@showProfile')->name('profile'); 
ii. Route::get('user/prfile',['as'=>'profile','uses'=>'UserController@showProfile']);

4. How to display a route name 
  Route::get('/',function(){
    echo route('profile',[123]);              using route
  })

  Route::get('/',function(){
    echo url('user/dashboard/profile',[123]);  using url
  })

@why we use {} braces ? 
@@ To assign paramters in route 

5. Route group with namespace
when controllers are made by creating extra directories i.e Admin/controllers,then it is used.
Route::group(['namespace'=>'Admin'],function(){
   Route::get('/','controllerName@methodName1');
   Route::get('/','controllerName@methodName2');

});

6. Route group with Domain
Route::group(['domain'=>'{domain}'],function(){
   Route::get('/',usercontroller@dashboard);

})
when we type mohit.example.com then mohit will be store in dashboard method in usercontroller 

7. Route group with prefix 
Route::group(['prefix'=>'admin'],function(){
    Route::get('/','c@m');
    Route::post('/','c@m');
});

8. Nested Route groups
Route::group(['prefix'=>'dashboard'],function(){ 
  Route::group(['prefix'=>'admin'],function(){
    Route::get('/','c@m');
    Route::post('/','c@m');
  });
   Route::group(['prefix'=>'user'],function(){
    Route::get('/','c@m');
    Route::post('/','c@m');
  });
})

9. Route to access any method get,post,put,patch,delete
Route::any('/','c@m');

10. Route to access only required methods
Route::match(['put','patch'],'/','c@m')


Route:Resource @@@

#HOW TO PASS DATA TO VIEW
1. No Data
   Route::get('/',function(){
   return view('view_name');	
});

2. Using compact
   Route::get('/',function(){
     $alphabets = array('a','b','c');
     return view('view_name',compact('alphabets'));	
   });
   In view: <?php print_r($alphabets); ?>  

3. Without Using Compact
   Route::get('/',function(){
     $data = array('a','b','c');
     return view('view_name',['aplhabets'=>$data]);
   });
   In view: <?php print_r($alphabets); ?> 
   
3 Using View::make()
  Route::get('/',function(){
    $data = array('a','b','c');
    return View::make('view_name',compact('alphabets'));
  })  

4. Using with
   return view('view_name')
   ->with('data',$data)
   ->with('alphabets',$alphabets);
	OR
   return view('view_name')->with(['name'=>$name, 'address'=>$address]);
        OR
   return view('view_name')->withNames($data);
   In view: Print_r($names);

#Abstract Class : which contain all common methods and variables ,we cant create object of abstract class

#Interface : contain all unimplemented methods which must be implented in child classes , a child class can implements multiple interfaces

#Static variables and static methods are directly related to class while normal variables and methods are related to objects. 
class abc{
	public static function sum(){
   
	}
}

abc::sum();
abc::variablename;
return self::$variable_name NOT return $this->variable_name;     

#LATE STATIC BINDING : 
it assign value on run time not on compile time
return static::$variable_name 

#Dependency Injection
when a class is depend on object of another class/another class we just pass that object in constructor ..thus is called @
!! In laravel case, we use Model name (type hinting ) as parameter in constructor. then create model of that name and service container automatically 
create a object and pass it into that parameter.
!! we use @ to get depenedncy parameters by using them in paramter by doing typehinting.

#Method Overriding in traits :
In this , methods in traits gets a priority over methods defined in parent classes. And
self defined methods gets priority over traits 
i.e SELF Methods> Traits Methods> Parent Classes Methods

#Colliosions in Traits
when 2 same name function exist in 2 diff traits 
class abc{
  use trait1,trait2{
    trait1::methodname insteadof trait2
    trait2::methodname as  trait2Methdname 
  }
}

#Access Level in Traits:
when a method is private in a trait then how to access this method
trait trait1{
 private method sum(){
  echo "sum"; 
  }
 private method trait1(){
  echo "sum"; 
  }
};

class abc {
  use trait1{
    trait1::sum as public @case1
    trait1::methodname as public TESTSUM @case2 
  }
}

obj = new abc();
obj->sum();  @case1
obj->TESTSUM(); @case2

#Middleware
!!simple concept: Create,Register And Call
!!middleware can be called by using route,contoller or routegroup
!!It is used after starting of application and before execution of user defined code.
!!php artisan make:middleware LoggerMiddleware
@how to define it in route:
Route::get('middleware_testing',['middleware'=>'Loggerbla','uses'=>'AdminController@index']);
Route::get('middleware_testing','AdminController@index')->middleware('midname');
   OR
In controller,  public function __construct(){ $this->middleware(['mid1','mid2']); } 

@if multiple middlewares are there:
In Kernel.php,   $middlewareGroups = ["key"=>[\App\m1,\App\m2,\App\m3]];
Route::get('middleware_testing','c@m')->middleware(['middleware1','middleware2');

@how to assign middlewares to only specific methods i.e only dashboard and index methods
public function __construct(){
  $this->middleware(['auth','logger'],['only'=>['dashboard','index'],]);
}
   OR
public function __construct(){
  $this->middleware(['auth','logger'],['except'=>['index'],]);
}
!!We can assign multiple middlewares in multiple lines acc to requirements
public function __construct(){
  $this->middleware(['auth','logger'],[
      'except'=>['index'],
   ]);
   $this->middleware(['login'],[
     'only'=>['loginmethod'],
   ]);	
}

#VIEW BLADE:
!! it escape the html data from php 
!! it is used to include view layouts in standard manner
!! @yield('section_name') is used to create a section
!! @section('section_name') is used to get that section and @stop/@endsection to end
!! extends('folder/layout_file') is used to include layout files.
!! {{ $variable }} is used to get php code from variable escaping html code
!! {!! $variable !!} is used to get php code from variable as it is
!! unary ondition shortcut is replaced by $data or 'Not Available'
@if @elseif @else @endif
@unless @elseif @else @endif <= ??
@for @endfor
@foreach @endforeach
@while @endwhile
@break for break
@forelse($dataa as $data) [if part] @empty [else part] @endforelse  <= laravel blade feature  

#Override View Sections
masterlayout.php:  yields('content');
view1.php:   @extends('masterlayout.php') @section('content')   test 1 @endsection  
view2.php    @extends('view1.php') @section('content')  test 2 @endsection
output:  test 2  

#Include files:
@include must be used as it reduce time and error chances

!! @each('view_name',$data,'name by which variable is created in view_name','else case view');

@stack @push @endpush for css and js
